

##  代码

- 并发编程中，main方法结束就直接结束，time.sleep让main等待几秒。
- 不同目录下函数名大写表示权限为公共
- 单引号 byte、rune，双引号 字符串，反引号 展示输出
- 空切片和nil切片区别，nil切片是没有分配任何底层数组的切片。空切片是分配了底层数组但不包含任何元素的切片。
- `for i:=range{ }`是一种用于遍历切片、数组、字符串、映射（map）或通道（channel）的语法。
- `array:=make([]int,length)`这样，`var array [length]int`会报错
- 遍历输出字符串的方式：1. `printf（ %q ）`go语法安全转义 2.`string()` 类型转换
- range中的i是int,不是元素
- 链表中，变量声明：`var :=1 new()`用来声明指针变量 `make()` 用来初始化slice，map，channel。方法：`head.addNode(v)`  非方法：`addNode(head,v)`。
- nil只能判断函数，管道，切片，映射，接口，指针。
- 函数内部不可声明函数，但可以用闭包函数`:=` 
- &p 取p的地址，*p，p为地址时取p指向的值。`var p *int`：声明p存储int类型变量的地址。
- `for     ；（条件）；{ }` 满足条件退出，类似while
- 切片和数组区别：初始化时：`切片make，[]` `数组 [3]~ , [...]`传递：`切片指针，函数值`
- `return（true，false）`可直接用条件，如a==1
- 返回值名可在函数上定义，直接return
- 不换行，print（a ' '）
- 协程中，main方法结束程序就结束
- go range通道前先关闭
- defer是栈结构
- 函数可以多个返回值
- new传指针，make传值
- panic recover
- main init函数
- `func（）{}`定义一个匿名函数  `func（）{}（）`定义一个匿名函数并执行
- 通过`m:="string"  n=fmt.Sprintf("~",m)` 进行格式化
- `q=append(q,edges[x]...)`  将edges中的元素逐一添加，...表示将切片展开，追加到另一个上面。
- `var a func (int) int`   , `a:=func (b int) int {}`将函数作为参数传递
- chan输出前未关闭chan会报错，deadlock！因为循环输出时无值会死锁 close（ch）
- `wg.Wait()`有时候会在一个闭包内部，有时候在主携程
- `fmt.Scanf` 跳过输入的原因通常与 `fmt.Scanf` 对输入的解析方式有关。特别是在读取字符串时，`fmt.Scanf("%s", &name)` 和 `fmt.Scanf("%s", &message)` 使用 `%s` 格式化字符串，它会读取直到第一个空白字符（如空格、制表符或换行符）。因为它还会读取到输入缓冲区中的换行符
- go使用`github.com/confluentinc/confluent-kafka-go/v2/kafka`中的`kafka.NewProducer`是，一直显示未定义，这是由于go未开启`$env:CGO_ENABLED = "1"`，让go可以引用c的编译。且需要安装gcc编译器。
- 函数参数定义时使用 `...` 代表可变参数，也就是参数数量不定。可变参数允许传递任意数量的某种类型的参数给函数。可变参数必须是函数的最后一个参数。如果函数有其他参数，可变参数必须放在最后。可变参数实际上是一个切片（slice），在函数内部可以像操作切片那样使用它。
- 对于 `JsonRes` 结构体中的 `Data` 字段，选择使用 `interface{}` 是为了让这个字段能够灵活地存储不同类型的返回数据。这种设计通常用于通用的 API 响应结构，因为 API 的返回值可能会根据具体的请求内容而不同。

- go里面只有值传递，没有引用传递。比如传一个大型结构体时，实际上是吧指针值拷贝一份过去，而不是把整个

- 闭包特点

- | 第一段代码 | 20, 10 | `defer` 在声明时即捕获了参数的值。两个 `defer` 分别捕获了 `x` 的不同值（10 和 20），并按照逆序执行。 |
  | ---------- | ------ | ------------------------------------------------------------ |
  |            |        |                                                              |

  | 第二段代码 | 20, 20 | 闭包捕获的是变量的引用，`defer` 延迟执行闭包，此时 `x` 的值已经被修改为 `20`。 |
  | ---------- | ------ | ------------------------------------------------------------ |
  |            |        |                                                              |
  
- go run -gcflags="-m" main.go进行逃逸分析

- ### **3. `for` 与 `select` 的对比**

  | **特性**     | **`for` 循环**                       | **`select` 多路复用**              |
  | ------------ | ------------------------------------ | ---------------------------------- |
  | **用途**     | 适合单一任务的持续循环，如打印任务。 | 同时监听多个通道或定时任务。       |
  | **复杂度**   | 简单、代码直观                       | 适用于需要协调多个事件的复杂场景。 |
  | **并发模型** | 配合独立协程处理其他任务             | 在单个循环内处理所有事件。         |
  | **灵活性**   | 控制特定逻辑较容易                   | 统一监听多个事件，更灵活。         |
  
-  在函数或者方法等上面的注释前加 函数名 可以让其他地方看函数时显示注释，如

![](image\commentToFunc.png)

- 查找某个元素时，放在一个切片中，时间复杂度时O(n)，放在一个空结构体的map中， 他的时间复杂度时O(1).
- if语句判断时，判断一个bool值比判断string要快得多
- 函数中判断不如判断是否需要进入函数
- 结构体比map的效率还要高，因为结构体搜索是记录偏移量，而map也还是要计算散列的，slice则是直接遍历更慢





















## 结构

1.对于一些配置信息等每次都要检查的配置，不应该放在函数体内部，这样每次都会重新改变配置，导致更新不合理，应该放在结构的成员变量中

2.如果需要监听一个管道，有消息来就更新配置，需要将其放在主函数单开一个协程，而且如果使用select要有context .DONE ()保证能够退出，不然可能会出现异常导致该协程不关闭。另外如果改协程在函数内部，会导致每次调用该函数都启动一个协程。

3.理想情况应该将要每个部分需要的协程放在函数内部，将函数放在入口函数中调用，因为协程的生命周期不受创建函数本身的约束，调用函数关闭不影响。

4.在程序设计中，始终明确管理协程的生命周期，避免依赖程序强制退出来清理协程。

5.打印日志时要从调试角度考虑，并且日志等级要清楚

6.数据库，中间件的相关操作封装在models/moduleName下面，防止后续名称改变导致的问题

7.长时间定位不到一个问题时，应思考其他方法，比如在使用stream_load的时候，在IDE调试长时间不知道问题，转而使用postman，并且可以在里面获得错误信息

8.一个需要长时间运行的协程，正常流程不应该有 **return**

9.定位不到错误不急，实在不行一行行在脑子中运行下

10. 注意数据一致性问题，一些场景中，如用户配置下发redis时需要将配置写到数据库，否则用户重启时就会出现不一致
10. 







## 项目





