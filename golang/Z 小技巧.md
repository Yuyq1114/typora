

# 代码

- 并发编程中，main方法结束就直接结束，time.sleep让main等待几秒。
- 不同目录下函数名大写表示权限为公共
- 单引号 byte、rune，双引号 字符串，反引号 展示输出
- 空切片和nil切片区别，nil切片是没有分配任何底层数组的切片。空切片是分配了底层数组但不包含任何元素的切片。
- `for i:=range{ }`是一种用于遍历切片、数组、字符串、映射（map）或通道（channel）的语法。
- `array:=make([]int,length)`这样，`var array [length]int`会报错
- 遍历输出字符串的方式：1. `printf（ %q ）`go语法安全转义 2.`string()` 类型转换
- range中的i是int,不是元素
- 链表中，变量声明：`var :=1 new()`用来声明指针变量 `make()` 用来初始化slice，map，channel。方法：`head.addNode(v)`  非方法：`addNode(head,v)`。
- nil只能判断函数，管道，切片，映射，接口，指针。
- 函数内部不可声明函数，但可以用闭包函数`:=` 
- &p 取p的地址，*p，p为地址时取p指向的值。`var p *int`：声明p存储int类型变量的地址。
- | 特性     | 普通指针 `*T`  | `unsafe.Pointer`       |
  | -------- | -------------- | ---------------------- |
  | 类型安全 | ✅ 是类型安全的 | ❌ 不类型安全，任意转换 |

- `for     ；（条件）；{ }` 满足条件退出，类似while
- 切片和数组区别：初始化时：`切片make，[]` `数组 [3]~ , [...]`传递：`切片指针，函数值`
- `return（true，false）`可直接用条件，如a==1
- 返回值名可在函数上定义，直接return
- 不换行，print（a ' '）
- 协程中，main方法结束程序就结束
- go range通道前先关闭
- defer是栈结构
- 函数可以多个返回值
- new传指针，make传值；
- | `new(T)`  | 分配内存，返回指向零值的指针 | 所有类型（结构体、基本类型等） | `*T`（类型指针） | ❌ 只是清零       | `x := new(int)` 或 `new(MyStruct)`        |
  | --------- | ---------------------------- | ------------------------------ | ---------------- | ---------------- | ----------------------------------------- |
  | `make(T)` | 创建并初始化内部数据结构     | **只能用于：slice、map、chan** | `T`（非指针）    | ✅ 初始化底层结构 | `make([]int, 10)`、`make(map[string]int)` |

- panic recover
- main init函数
- `func（）{}`定义一个匿名函数  `func（）{}（）`定义一个匿名函数并执行
- 通过`m:="string"  n=fmt.Sprintf("~",m)` 进行格式化
- `q=append(q,edges[x]...)`  将edges中的元素逐一添加，...表示将切片展开，追加到另一个上面。
- `var a func (int) int`   , `a:=func (b int) int {}`将函数作为参数传递
- chan输出前未关闭chan会报错，deadlock！因为循环输出时无值会死锁 close（ch）
- `wg.Wait()`有时候会在一个闭包内部，有时候在主携程
- `fmt.Scanf` 跳过输入的原因通常与 `fmt.Scanf` 对输入的解析方式有关。特别是在读取字符串时，`fmt.Scanf("%s", &name)` 和 `fmt.Scanf("%s", &message)` 使用 `%s` 格式化字符串，它会读取直到第一个空白字符（如空格、制表符或换行符）。因为它还会读取到输入缓冲区中的换行符
- go使用`github.com/confluentinc/confluent-kafka-go/v2/kafka`中的`kafka.NewProducer`是，一直显示未定义，这是由于go未开启`$env:CGO_ENABLED = "1"`，让go可以引用c的编译。且需要安装gcc编译器。
- 函数参数定义时使用 `...` 代表可变参数，也就是参数数量不定。可变参数允许传递任意数量的某种类型的参数给函数。可变参数必须是函数的最后一个参数。如果函数有其他参数，可变参数必须放在最后。可变参数实际上是一个切片（slice），在函数内部可以像操作切片那样使用它。
- 对于 `JsonRes` 结构体中的 `Data` 字段，选择使用 `interface{}` 是为了让这个字段能够灵活地存储不同类型的返回数据。这种设计通常用于通用的 API 响应结构，因为 API 的返回值可能会根据具体的请求内容而不同。

- go里面只有值传递，没有引用传递。比如传一个大型结构体时，实际上是吧指针值拷贝一份过去，而不是把整个

- 闭包特点

- | 第一段代码 | 20, 10 | `defer` 在声明时即捕获了参数的值。两个 `defer` 分别捕获了 `x` 的不同值（10 和 20），并按照逆序执行。 |
  | ---------- | ------ | ------------------------------------------------------------ |
  |            |        |                                                              |

  | 第二段代码 | 20, 20 | 闭包捕获的是变量的引用，`defer` 延迟执行闭包，此时 `x` 的值已经被修改为 `20`。 |
  | ---------- | ------ | ------------------------------------------------------------ |
  |            |        |                                                              |
  
- go run -gcflags="-m" main.go进行逃逸分析

- ### **3. `for` 与 `select` 的对比**

  | **特性**     | **`for` 循环**                       | **`select` 多路复用**              |
  | ------------ | ------------------------------------ | ---------------------------------- |
  | **用途**     | 适合单一任务的持续循环，如打印任务。 | 同时监听多个通道或定时任务。       |
  | **复杂度**   | 简单、代码直观                       | 适用于需要协调多个事件的复杂场景。 |
  | **并发模型** | 配合独立协程处理其他任务             | 在单个循环内处理所有事件。         |
  | **灵活性**   | 控制特定逻辑较容易                   | 统一监听多个事件，更灵活。         |
  
-  在函数或者方法等上面的注释前加 函数名 可以让其他地方看函数时显示注释，如

![](image\commentToFunc.png)

- 查找某个元素时，放在一个切片中，时间复杂度时O(n)，放在一个空结构体的map中， 他的时间复杂度时O(1).

- if语句判断时，判断一个bool值比判断string要快得多

- 函数中判断不如判断是否需要进入函数

- 结构体比map的效率还要高，因为结构体搜索是记录偏移量，而map也还是要计算散列的，slice则是直接遍历更慢

- 禁止使用一些莫名其奇妙的数字作为判断，使用静态变量

- 在涉及到数据库操作相关的业务时，不仅考虑写，还要考虑删除更新

- 在极高数据量的情况下，使用gorm的update或者batchinsert会出现错误，可以使用中间表的方式进行插入。

- 嵌套map，不止外层map需要初始化，内层也需要初始化，不然会空指针错误

- 在碰到或者使用指针时，千万小心空指针的问题。一定要考虑空指针的异常

- 如果你想要**修改外部变量的值、节省内存或处理大型数据结构**或想要nil表示没有值，就用指针。

- Go 所有传参、赋值、返回都是**值传递**。但有些类型（slice、map、chan、interface）**内部带指针**，表现出引用行为。但是array和**struct**真正想修改外部数据，请**传指针 `\*T` 或引用类型**。

- ```
  type A struct {
  	Id   int
  	Name string
  	test *string
  }
  aMap := make(map[int]A)
  bMap := new(A)
  c := "asd"
  aMap[1] = A{1, "a", &c}
  aMap[1].Name = "bc" //报错
  
  a := make(map[int]string)
  a[1] = "a"
  b := make(map[int]map[int]string)
  b[1] = a
  fmt.Println(b[1][1])
  b[1][1] = "b"
  fmt.Println(b[1][1]) //不报错
  ```

  ```
  package main
  
  import "fmt"
  
  func change(arr []int) {
  	arr[0] = 999
  }
  func change2(arr [3]int) {
  	arr[0] = 999
  }
  func change3(arr [3]int) [3]int {
  	arr[0] = 999
  	return arr
  }
  func main() {
  	a := []int{1, 2, 3}
  	change(a)
  	fmt.Println(a[0]) // 999
  	b := [3]int{1, 2, 3}
  	change2(b)
  	fmt.Println(b[0]) // 1
  	c := change3(b)
  	fmt.Println(c[0]) // 999
  }
  
  ```
  
- go中的死锁检测机制，Go runtime 内部有一个 goroutine 状态追踪系统（调度器）：

  - 会周期性检查 **是否有 goroutine 处于运行态**
  - 如果全部 goroutine 都是：`chan send`、`chan recv`、`select wait`、`mutex lock` 等状态
  - 并且没有定时器可唤醒，没有网络事件等外部输入
  - **就会 panic 报死锁**

  解决办法就是，先启动消费协程，在启动主生产协程。

- 大部分情况下，直接使用make就好，不需要使用var，var会默认分配零值，容易造成空指针问题。另外如果创建一个切片往里面append写数据，注意初始化长度为0。var和new的区别在于，new初始化一个指针，分配在堆上，var初始化的是值类型，分配位置由编译器决定。

- ```
  a := new([]int)
  *a = []int{0}
  fmt.Println((*a)[0])
  b := new([2]int)
  fmt.Println(b[0])   //数组在 Go 中是值类型，b[0] 相当于 (*b)[0]，Go 自动做了解引用。
  ```























# 结构

1.对于一些配置信息等每次都要检查的配置，不应该放在函数体内部，这样每次都会重新改变配置，导致更新不合理，应该放在结构的成员变量中

2.如果需要监听一个管道，有消息来就更新配置，需要将其放在主函数单开一个协程，而且如果使用select要有context .DONE ()保证能够退出，不然可能会出现异常导致该协程不关闭。另外如果改协程在函数内部，会导致每次调用该函数都启动一个协程。

3.理想情况应该将要每个部分需要的协程放在函数内部，将函数放在入口函数中调用，因为协程的生命周期不受创建函数本身的约束，调用函数关闭不影响。

4.在程序设计中，始终明确管理协程的生命周期，避免依赖程序强制退出来清理协程。如select{}

5.打印日志时要从调试角度考虑，并且日志等级要清楚，而且不只是失败有日志，成功了也要有INFO。

6.数据库，中间件的相关操作封装在models/moduleName下面，防止后续名称改变导致的问题

7.长时间定位不到一个问题时，应思考其他方法，比如在使用stream_load的时候，在IDE调试长时间不知道问题，转而使用postman，并且可以在里面获得错误信息

8.一个需要长时间运行的协程，正常流程不应该有 **return**

9.定位不到错误不急，实在不行一行行在脑子中运行下

10. 注意数据一致性问题，一些场景中，如用户配置下发redis时需要将配置写到数据库，否则用户重启时就会出现不一致

10. 注意多协程操作时一些结构的并发不安全问题，比如切片

10. 多协程时一定要考虑主函数中的各个地方的执行顺序，以及执行时间，比如最后一步想要写库时，因为主函数直接执行，所以执行一次就没了，所以要先阻塞住（对资源Add(1)），最后写库。同时空结构体类型的channel也可以作为资源控制的东西。

    





# DEBUG

1、数据本身：在每个函数入口或者说每次获取数据的时候，先要看数据是否正确，这样能够确定错误至少在哪一步发生

2、如果某个地方有bug，先思考最下面这个数据怎么产生的，然后最下面模块的数据是怎么来的，一步步向上思考可能出现的模块问题，进行处理。

3、













# 项目

1、前期需求一定明确，即使不明确，也要做好冗余设计，不然后期随着故障或者需求一直变更，代码就会越来越恶心，像一坨毫无逻辑的字母混合物。另外需求明确后考虑的地方也要多一点，原则上考虑上游 下游 和当前数据的 增删改查 就够全面了。

2、





