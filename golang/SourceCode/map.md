# map定义

定义位置src\runtime\map_noswiss.go，

```
type hmap struct {
	// Note: the format of the hmap is also encoded in cmd/compile/internal/reflectdata/reflect.go.
	// Make sure this stays in sync with the compiler's definition.
	count     int // # live cells == size of map.  Must be first (used by len() builtin) map 中元素的数量。
	flags     uint8 用于标志 map 的状态（是否写保护、是否正在扩容等）。
	B         uint8  // log_2 of # of buckets (can hold up to loadFactor * 2^B items)表示当前的桶数量，桶的数量是 2^B。
	noverflow uint16 // approximate number of overflow buckets; see incrnoverflow for details表示溢出桶的数量。Go 中的 map 可能会在同一个哈希桶中存储太多元素，这时需要用溢出桶来存储这些元素。
	hash0     uint32 // hash seed哈希种子，防止哈希碰撞攻击。

	buckets    unsafe.Pointer // array of 2^B Buckets. may be nil if count==0.指向 map 的桶数组，实际存储 map 中元素的地方。
	oldbuckets unsafe.Pointer // previous bucket array of half the size, non-nil only when growing旧的桶数组指针。在 map 进行扩容时，新桶和旧桶之间可能需要进行数据搬移，所以保留对旧桶的引用。
	nevacuate  uintptr        // progress counter for evacuation (buckets less than this have been evacuated)在扩容时，记录已经搬移了多少桶。

	extra *mapextra // optional fields用于存放一些额外的字段，比如溢出桶等。
}
```

# 创建一个map

src\runtime\map_noswiss.go中的makemap函数，

```
// makemap implements Go map creation for make(map[k]v, hint).
h = new(hmap)//分配内存
h.hash0 = uint32(rand())//设置hash
B := uint8(0)//设置桶数量
h.buckets, nextOverflow = makeBucketArray(t, h.B, nil)//makeBucketArray initializes a backing array for map buckets.
```

具体的：

```
makeBucketArray(t, h.B, nil)函数如下
if dirtyalloc == nil {//没有现成的内存块来分配 buckets。因此，需要为哈希表的桶分配新的内存。
		buckets = newarray(t.Bucket, int(nbuckets))//t.Bucket 是每个桶的类型，nbuckets 是桶的数量。newarray 函数分配一块新的连续内存，用于存储这些桶。
	} else {//之前已经分配了一块内存
		// dirtyalloc was previously generated by
		// the above newarray(t.Bucket, int(nbuckets))
		// but may not be empty.
		buckets = dirtyalloc//dirtyalloc 已经是指向一个现有内存块的指针，所以将其赋值给 buckets。
		size := t.Bucket.Size_ * nbuckets
		//下面的表示无论是否重复使用旧的内存块，都需要将这块内存清零
		if t.Bucket.Pointers() {
			memclrHasPointers(buckets, size)
		} else {
			memclrNoHeapPointers(buckets, size)
		}
	}

```

# 并发安全map

```
type Map struct {
    mu Mutex

    // read contains the portion of the map's contents that are safe for
    // concurrent access (with or without mu held).
    //
    // The read field itself is always safe to load, but must only be stored with
    // mu held.
    //
    // Entries stored in read may be updated concurrently without mu, but updating
    // a previously-expunged entry requires that the entry be copied to the dirty
    // map and unexpunged with mu held.
    read atomic.Pointer[readOnly]

    // dirty contains the portion of the map's contents that require mu to be
    // held. To ensure that the dirty map can be promoted to the read map quickly,
    // it also includes all of the non-expunged entries in the read map.
    //
    // Expunged entries are not stored in the dirty map. An expunged entry in the
    // clean map must be unexpunged and added to the dirty map before a new value
    // can be stored to it.
    //
    // If the dirty map is nil, the next write to the map will initialize it by
    // making a shallow copy of the clean map, omitting stale entries.
    dirty map[any]*entry

    // misses counts the number of loads since the read map was last updated that
    // needed to lock mu to determine whether the key was present.
    //
    // Once enough misses have occurred to cover the cost of copying the dirty
    // map, the dirty map will be promoted to the read map (in the unamended
    // state) and the next store to the map will make a new dirty copy.
    misses int
}
```