# 一 变量

## 1定义方式

**使用 `var` 关键字**：

```
var identifier type
var age int
var name string
```

**使用 `var` 关键字同时定义多个变量**：

```
var (
    age    int
    name   string
    salary float64
)
```

**使用 `:=` 简短变量声明**：

```
identifier := value
age := 25
name := "Alice"
```

简短变量声明形式只能在函数内部使用，用来声明并初始化变量。

## 2类型推断

在使用 `:=` 简短变量声明时，如果省略了类型说明符，编译器会根据初始化表达式推断出变量的类型。

## 3零值

数值类型（如 `int`, `float64`）的零值为 `0`。

布尔类型的零值为 `false`。

字符串类型的零值为空字符串 `""`。

指针类型的零值为 `nil`。

## 4变量的特性

**类型安全**：

- Go语言是静态类型语言，变量在声明时必须指定类型，且类型不可改变。

**作用域**：

- 变量的作用域（Scope）取决于它们的声明位置。通常，变量在其声明的代码块内可见和可用。

**声明后必须使用**：

- 在Go语言中，声明后的变量必须被使用，否则会引发编译错误。

**重复声明**：

- 在同一作用域内，不允许重复声明同名变量。



# 二 常量

## 1定义方式

### 使用`const`关键字

使用`const`关键字可以定义常量，格式为：

```
const identifier = value
```

其中：

- `identifier` 是常量的名称。
- `value` 是常量的值，可以是基本类型（如整数、浮点数、字符串）、布尔值或枚举类型。

### 使用`iota`常量生成器

`iota`是Go语言的一个特殊常量，可以用来生成一组以相似规则递增的常量。在常量组中，每出现一次`iota`，其值就会自动递增1。

`const (
    Monday    = iota // 0
    Tuesday          // 1
    Wednesday        // 2
    Thursday         // 3
    Friday           // 4
    Saturday         // 5
    Sunday           // 6
)`

## 2 常量特性

**不可修改**：

- 常量一旦被定义，在程序运行过程中其值不可更改。

**编译时确定**：

- 常量的值在编译时确定，而不是在运行时。

**类型推断**：

- 如果常量没有明确的类型，那么根据上下文推断其类型。

**常量表达式**：

- 常量可以通过常量表达式定义，表达式中只能出现常量和内置函数。



# 三 数据类型

## 1. 基本数据类型

基本数据类型是构建所有其他类型的基础，包括数值类型、布尔类型和字符串类型。

- **整数类型**：
  - `int`：根据系统架构选择32位或64位整数。
  - `int8`、`int16`、`int32`、`int64`：有符号整数，分别为8位、16位、32位和64位。
  - `uint`、`uint8`、`uint16`、`uint32`、`uint64`：无符号整数，分别为对应位数的无符号整数。
  - `uintptr`：用于存放一个指针。
- **浮点数类型**：
  - `float32`：32位浮点数。
  - `float64`：64位浮点数。
- **复数类型**：
  - `complex64`：由两个32位浮点数表示的复数。
  - `complex128`：由两个64位浮点数表示的复数。
- **布尔类型**：
  - `bool`：表示真（true）或假（false）的布尔值。
- **字符串类型**：
  - `string`：表示任意UTF-8字符串的类型。

## 2. 复合数据类型

复合数据类型是由基本数据类型或其他复合数据类型组成的数据类型。

- **数组（Array）**：
  - `var arr [5]int`：表示包含5个整数的数组。
- **切片（Slice）**：
  - `var slice []int`：不定长度的数组切片。
- **字典（Map）**：
  - `var dict map[string]int`：映射键值对的集合。
- **结构体（Struct）**：
  - `type Person struct { Name string; Age int }`：定义一个包含姓名和年龄的结构体。

## 3. 特殊数据类型

特殊数据类型用于表示特定的值或者不同类型之间的转换。

- **空接口（Empty Interface）**：
  - `interface{}`：可以表示任意类型的值。
- **函数类型（Function Type）**：
  - `func(int) float64`：表示接受一个整数参数并返回一个浮点数的函数类型。
- **通道类型（Channel Type）**：
  - `chan int`：用于在 goroutine 之间进行通信的数据类型。

## 类型转换

在Go语言中，类型转换可以通过显式转换实现，例如将一个整数转换为浮点数

```
var x int = 10
var y float64 = float64(x)
```

# 四 运算符

### 1. 算术运算符

算术运算符用于执行基本的数学运算，例如加法、减法、乘法、除法等。

- **加法 `+`**：相加操作。

  ```
  sum := a + b
  ```

- **减法 `-`**：相减操作。

  ```
  diff := a - b
  ```

- **乘法 `\*`**：相乘操作。

  ```
  product := a * b
  ```

- **除法 `/`**：相除操作。

  ```
  quotient := a / b
  ```

- **取余 `%`**：取余操作。

  ```
  remainder := a % b
  ```

### 2. 关系运算符

关系运算符用于比较两个值的大小关系，返回布尔值 `true` 或 `false`。

- **相等 `==`**：判断两个值是否相等。

  ```
  isEqual := (a == b)
  ```

- **不相等 `!=`**：判断两个值是否不相等。

  ```
  isNotEqual := (a != b)
  ```

- **大于 `>`**：判断左操作数是否大于右操作数。

  ```
  isGreater := (a > b)
  ```

- **小于 `<`**：判断左操作数是否小于右操作数。

  ```
  isLess := (a < b)
  ```

- **大于等于 `>=`**：判断左操作数是否大于等于右操作数。

  ```
  isGreaterOrEqual := (a >= b)
  ```

- **小于等于 `<=`**：判断左操作数是否小于等于右操作数。

  ```
  isLessOrEqual := (a <= b)
  ```

### 3. 逻辑运算符

逻辑运算符用于组合多个条件，返回布尔值 `true` 或 `false`。

- **逻辑与 `&&`**：两个操作数都为 `true` 才为 `true`，否则为 `false`。

  ```
  result := (p && q)
  ```

- **逻辑或 `||`**：两个操作数任意一个为 `true` 就为 `true`，否则为 `false`。

  ```
  result := (p || q)
  ```

- **逻辑非 `!`**：操作数为 `true` 则为 `false`，操作数为 `false` 则为 `true`。

  ```
  result := !p
  ```

### 4. 位运算符

位运算符用于对整数的二进制位进行操作。

- **按位与 `&`**：对应位都为 `1` 才为 `1`，否则为 `0`。

  ```
  result := a & b
  ```

- **按位或 `|`**：对应位有一个为 `1` 就为 `1`，否则为 `0`。

  ```
  result := a | b
  ```

- **按位异或 `^`**：对应位不同时为 `1`，相同为 `0`。

  ```
  result := a ^ b
  ```

- **按位取反 `^`**：操作数的每个位取反。

  ```
  result := ^a
  ```

- **左移 `<<`**：将操作数的二进制位向左移动指定的位数。

  ```
  result := a << b
  ```

- **右移 `>>`**：将操作数的二进制位向右移动指定的位数。

  ```
  result := a >> b
  ```

### 5. 赋值运算符

赋值运算符用于将值赋给变量。

- **赋值 `=`**：将右侧表达式的值赋给左侧变量。

  ```
  var x int
  x = 10
  ```

- **加法赋值 `+=`**：相加并将结果赋给左侧变量。

  ```
  x += 5  // 等价于 x = x + 5
  ```

- **减法赋值 `-=`**：相减并将结果赋给左侧变量。

  ```
  x -= 3  // 等价于 x = x - 3
  ```

- **乘法赋值 `\*=`**：相乘并将结果赋给左侧变量。

  ```
  x *= 2  // 等价于 x = x * 2
  ```

- **除法赋值 `/=`**：相除并将结果赋给左侧变量。

  ```
  x /= 4  // 等价于 x = x / 4
  ```

- **取余赋值 `%=`**：取余并将结果赋给左侧变量。

  ```
  x %= 3  // 等价于 x = x % 3
  ```

### 6. 其他特殊运算符

- **取地址 `&`**：返回变量的内存地址。

  ```
  var ptr *int
  ptr = &x
  ```

- **取值 `\*`**：返回指针指向地址的值。

  ```
  val := *ptr
  ```

- **通道操作符 `<-`**：发送和接收操作，用于通道通信。

  ```
  ch <- value    // 发送数据到通道
  value := <-ch  // 从通道接收数据
  ```



# 五 格式化输出

格式化输出是通过 `fmt` 包提供的函数实现的，主要用于将数据格式化为字符串并输出到标准输出或其他输出流。

在Go语言中，格式化输出是通过 `fmt` 包提供的函数实现的，主要用于将数据格式化为字符串并输出到标准输出或其他输出流。格式化输出是程序中常用的调试和展示数据的方式之一。以下是Go语言中常用的格式化输出方法和示例：

### 1. 使用 `fmt.Printf()`

`fmt.Printf()` 函数按照指定的格式将数据输出到标准输出（通常是终端窗口）。

### 2. 使用 `fmt.Sprintf()`

`fmt.Sprintf()` 函数格式化数据并返回格式化后的字符串，常用于将格式化后的数据存储在变量中或进行其他处理。

```
package main

import "fmt"

func main() {
    name := "Alice"
    age := 30
    formatted := fmt.Sprintf("Name: %s, Age: %d", name, age)
    fmt.Println(formatted)
}
```



### 3. 使用 `fmt.Fprintf()`

`fmt.Fprintf()` 函数用于将格式化后的数据输出到指定的 `io.Writer` 接口。

```
package main

import (
    "fmt"
    "os"
)

func main() {
    name := "Alice"
    age := 30
    fmt.Fprintf(os.Stdout, "Name: %s, Age: %d\n", name, age)
}
```

## 格式化指示符

**整数**：

- `%d`：十进制整数。
- `%b`：二进制整数。
- `%o`：八进制整数。
- `%x`, `%X`：十六进制整数，`%X` 输出大写字母

**浮点数**：

- `%f`：标准的浮点数格式。
- `%e`, `%E`：科学记数法表示浮点数，`%E` 输出大写字母。

**字符串**：

- `%s`：字符串。
- `%q`：带双引号的字符串。

**布尔值**：

- `%t`：布尔值。

**指针**：

- `%p`：指针的十六进制表示。

**宽度和精度**：

- `%5d`：最小宽度为5的整数，右对齐。
- `%-5d`：最小宽度为5的整数，左对齐。
- `%.2f`：浮点数保留两位小数。

**特殊指示符**

- `%v` 用于以默认格式输出变量的值。对于不同的数据类型，`%v` 的输出方式有所不同：
- `%+v` 会包含字段名称的详细格式输出。
- `%T` 用于输出变量的类型。

# 六 格式化输入

**`fmt.Scan`**: 用于从标准输入中读取数据，按空格分隔。读取的数据会被解析为对应的变量类型。

```
var name string
var age int
fmt.Scan(&name, &age)
```

**`fmt.Scanf`**: 允许使用格式化字符串来指定输入的格式。例如，如果你希望按特定格式读取数据，可以使用这个函数。在读取字符串时，`fmt.Scanf("%s", &name)` 和 `fmt.Scanf("%s", &message)` 使用 `%s` 格式化字符串，它会读取直到第一个空白字符（如空格、制表符或换行符）。这意味着如果用户在输入 `name` 后直接按下 `Enter` 键，`fmt.Scanf("%s", &message)` 可能会**跳过**，因为它还会读取到输入缓冲区中的换行符。

```
var name string
var age int
fmt.Scanf("%s %d", &name, &age)
```

**`fmt.Sscan`**: 用于从字符串中读取数据，与 `fmt.Scan` 类似，但它是从一个字符串而不是标准输入中读取。

```
var name string
var age int
input := "John 30"
fmt.Sscan(input, &name, &age)
```

**`fmt.Sscanf`**: 用于从字符串中读取数据，并且可以使用格式化字符串来指定格式。

```
var name string
var age int
input := "John 30"
fmt.Sscanf(input, "%s %d", &name, &age)
```

**`fmt.Scanln`**: 从标准输入中读取数据，直到遇到换行符。它可以用于读取一整行数据。

```
var line string
fmt.Scanln(&line)
```

