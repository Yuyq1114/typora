# 交叉编译

## 到linux下：

**在cmd中：**

set GOOS=linux
set GOARCH=amd64
go build -o test main.go

**查看环境 go env**

**在powershell中**

$env:GOOS="linux"
$env:GOARCH="amd64"
go build -o test main.go

### 在linux中：

chmod +x test

./test

file ./test 应该输出./test: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 2.6.32, 、

**注意开放端口：**

```
systemctl start firewalld      # 启动防火墙
systemctl status firewalld     # 查看防火墙状态
systemctl stop firewalld       # 关闭防火墙

systemctl disable firewalld    # 开启不启动防火墙
systemctl enable firewalld     # 开机启动防火墙
```

```
firewall-cmd --zone=public --add-port=9200/tcp --permanent     # 开放端口
firewall-cmd --zone=public --remove-port=9200/tcp --permanent  # 关闭端口
firewall-cmd --reload                                          # 重新载入配置，让开放或关闭的端口配置生效
```

```
firewall-cmd --zone=public --list-ports            # 查询端口开放列表
firewall-cmd --zone=public --query-port=9200/tcp   # 查询具体端口是否开放
```

## 到安卓下

**安装 Android NDK**：

- 你可以从 [Android NDK 下载页面](https://developer.android.com/ndk/downloads) 下载和安装 NDK。
- 解压 NDK 并记下其路径，例如 `/path/to/android-ndk`.

 在 Windows 上，可以在系统环境变量中设置 `ANDROID_NDK`



# 正则表达式：

正则表达式（Regular Expression，简称 regex 或 regexp）是一种用来匹配字符串中字符模式的工具。它是一种强大的文本处理工具，可以用于搜索、替换、解析和验证字符串。正则表达式在许多编程语言中都有实现，并且是许多文本编辑器和命令行工具的一部分。

### 基本概念

- **字符**：普通字符（如字母、数字）匹配其字面意思。
- **元字符**：有特殊意义的字符，如 `.`、`*`、`?`、`[]`、`()` 等。
- **转义字符**：使用反斜杠 `\` 来取消元字符的特殊意义，使其匹配字面值。

### 常见的元字符及其含义

- `.`：匹配除换行符以外的任何单个字符。
- `^`：匹配字符串的开头。
- `$`：匹配字符串的结尾。
- `*`：匹配前面的子表达式零次或多次。
- `+`：匹配前面的子表达式一次或多次。
- `?`：匹配前面的子表达式零次或一次。
- `{n}`：匹配前面的子表达式恰好 n 次。
- `{n,}`：匹配前面的子表达式至少 n 次。
- `{n,m}`：匹配前面的子表达式至少 n 次，至多 m 次。
- `[]`：匹配方括号内的任意字符（字符集）。
- `|`：匹配左右任意一个表达式（或）。
- `()`：捕获组，用于提取匹配的子字符串。

### 字符集和预定义字符集

- `[abc]`：匹配 `a`、`b` 或 `c` 中的任意一个字符。
- `[a-z]`：匹配任意一个小写字母。
- `\d`：匹配任何一个数字，相当于 `[0-9]`。
- `\D`：匹配任何一个非数字字符，相当于 `[^0-9]`。
- `\w`：匹配任何一个字母、数字或下划线，相当于 `[a-zA-Z0-9_]`。
- `\W`：匹配任何一个非字母、数字或下划线字符，相当于 `[^a-zA-Z0-9_]`。
- `\s`：匹配任何一个空白字符（包括空格、制表符、换行符等）。
- `\S`：匹配任何一个非空白字符。

### 常见正则表达式示例

1. **匹配一个电子邮件地址**：

   ```
   ^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$
   ```

2. **匹配一个IP地址**：

   ```
   ^(\d{1,3}\.){3}\d{1,3}$
   ```

3. **匹配一个URL**：

   ```
   ^https?:\/\/[^\s/$.?#].[^\s]*$
   ```

4. **匹配一个电话号码（美国）**：

   ```
   ^\(\d{3}\) \d{3}-\d{4}$
   ```

5. **匹配日期格式（YYYY-MM-DD）**：

   ```
   ^\d{4}-\d{2}-\d{2}$
   ```

### 零宽断言

是**一种零宽度的匹配，它匹配到的内容不会保存到匹配结果中去，最终匹配结果只是一个位置而已**。 正则表达式中常用的断言元字符为： ^ 和 $ 和 \b ，而零宽断言就是其他用正则表达式来定义的功能类似的断言。 这意味着它们只检查某个位置前后是否符合条件，而不会包括在最终的匹配结果中。



### 使用正则表达式的编程示例（Go 语言）

在 Go 语言中，可以使用 `regexp` 包来处理正则表达式。以下是一些示例代码：

#### 检查字符串是否匹配模式

```
package main

import (
	"fmt"
	"regexp"
)

func main() {
	match, _ := regexp.MatchString(`^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$`, "example@example.com")
	fmt.Println(match) // 输出: true
}
```

#### 提取字符串中的匹配部分

```
package main

import (
	"fmt"
	"regexp"
)

func main() {
	re := regexp.MustCompile(`(\d{4})-(\d{2})-(\d{2})`)
	match := re.FindStringSubmatch("2024-08-07")
	fmt.Println(match) // 输出: [2024-08-07 2024 08 07]
}
```

#### 替换字符串中的匹配部分

```
package main

import (
	"fmt"
	"regexp"
)

func main() {
	re := regexp.MustCompile(`foo`)
	result := re.ReplaceAllString("foo bar foo baz foo", "bar")
	fmt.Println(result) // 输出: bar bar bar baz bar
}
```

#### 分割字符串

```
package main

import (
	"fmt"
	"regexp"
)

func main() {
	re := regexp.MustCompile(`\s+`)
	parts := re.Split("a b  c   d", -1)
	fmt.Println(parts) // 输出: [a b c d]
}
```





# 数据格式

### JSON 数据格式

JSON主要由两种结构组成：

1. **对象（Object）**：包含一组键值对（key-value pairs），用花括号 `{}` 包围。
2. **数组（Array）**：包含一个有序的值列表，用方括号 `[]` 包围。

### 示例

#### JSON 对象

```
{
  "name": "John",
  "age": 30,
  "isStudent": false,
  "address": {
    "street": "123 Main St",
    "city": "Anytown"
  },
  "courses": ["Math", "Science", "History"]
}
```

在这个示例中：

- `"name"` 是一个字符串。
- `"age"` 是一个数值。
- `"isStudent"` 是一个布尔值。
- `"address"` 是另一个对象，包含两个键值对。
- `"courses"` 是一个数组，包含三个字符串。

### JSON 语法规则

1. **数据在键值对中**：如上例所示，每个键值对用冒号 `:` 分隔。
2. **数据由逗号分隔**：多个键值对或数组元素之间用逗号 `,` 分隔。
3. **花括号 `{} `用于包含对象**：对象表示为键值对的集合。
4. **方括号 `[]` 用于包含数组**：数组表示为值的有序集合。
5. **键** 必须是字符串：键必须用双引号 `""` 括起来。
6. **值** 可以是字符串、数字、布尔值、数组、对象或 `null`。



### 1. XML（eXtensible Markup Language）

- **描述**：XML 是一种标记语言，用于定义文档的结构。它使用标签（tags）来定义数据。

- **应用**：配置文件、文档格式（如 DOCX、SVG）、网络协议（如 SOAP）。

- 示例

  ：

  ```
  <person>
      <name>John</name>
      <age>30</age>
      <address>
          <street>123 Main St</street>
          <city>Anytown</city>
      </address>
      <courses>
          <course>Math</course>
          <course>Science</course>
          <course>History</course>
      </courses>
  </person>
  ```

### 2. YAML（YAML Ain't Markup Language）

- **描述**：YAML 是一种以人类可读性为主的数据序列化标准，常用于配置文件。

- **应用**：配置文件（如 Docker Compose、Kubernetes 配置）、数据存储。

- 示例

  ：

  ```
  person:
    name: John
    age: 30
    address:
      street: 123 Main St
      city: Anytown
    courses:
      - Math
      - Science
      - History
  ```

### 3. CSV（Comma-Separated Values）

- **描述**：CSV 是一种简单的文件格式，用于以纯文本形式存储表格数据。

- **应用**：数据交换、导入/导出表格数据、电子表格。

- 示例

  ：

  ```
  name,age,address,city,courses
  John,30,123 Main St,Anytown,"Math, Science, History"
  ```

### 4. Protocol Buffers（protobuf）

- **描述**：由 Google 开发的一种高效的数据序列化格式。它需要预定义的数据结构（schema）。

- **应用**：网络通信、数据存储、远程过程调用（RPC）。

- 示例

  ：

  ```
  message Person {
    string name = 1;
    int32 age = 2;
    message Address {
      string street = 1;
      string city = 2;
    }
    Address address = 3;
    repeated string courses = 4;
  }
  ```

### 5. MessagePack

- **描述**：一种高效的二进制序列化格式，类似于 JSON，但更紧凑。

- **应用**：网络通信、高性能应用程序。

- 示例

  ：

  ```
  { "name": "John", "age": 30, "address": { "street": "123 Main St", "city": "Anytown" }, "courses": ["Math", "Science", "History"] }
  ```

  MessagePack 格式在内部将此 JSON 表示为紧凑的二进制格式。

### 6. INI

- **描述**：一种简单的配置文件格式，常用于配置文件。

- **应用**：配置文件（如 Windows 配置文件、某些应用程序配置）。

- 示例

  ：

  ```
  [person]
  name = John
  age = 30
  
  [address]
  street = 123 Main St
  city = Anytown
  
  [courses]
  course1 = Math
  course2 = Science
  course3 = History
  ```

### 7. TOML（Tom's Obvious, Minimal Language）

- **描述**：一种简单易读的配置文件格式，旨在替代 JSON 和 XML。

- **应用**：配置文件（如 Rust 项目配置）。

- 示例

  ：

  ```
  [person]
  name = "John"
  age = 30
  
  [address]
  street = "123 Main St"
  city = "Anytown"
  
  [[courses]]
  name = "Math"
  
  [[courses]]
  name = "Science"
  
  [[courses]]
  name = "History"
  ```

### 8. BSON（Binary JSON）

- **描述**：一种二进制序列化格式，类似于 JSON，但增加了类型信息和二进制数据支持。

- **应用**：MongoDB 数据存储。

- 示例

  ：

  ```
  { "name": "John", "age": 30, "address": { "street": "123 Main St", "city": "Anytown" }, "courses": ["Math", "Science", "History"] }
  ```

  BSON 格式在内部将此 JSON 表示为带有类型信息的二进制格式。

### 9. Avro

- **描述**：由 Apache 开发的一种二进制序列化格式，具有丰富的 schema 定义支持。

- **应用**：大数据处理（如 Apache Kafka、Apache Hadoop）。

- 示例

  ：

  ```
  {
    "type": "record",
    "name": "Person",
    "fields": [
      { "name": "name", "type": "string" },
      { "name": "age", "type": "int" },
      {
        "name": "address",
        "type": {
          "type": "record",
          "name": "Address",
          "fields": [
            { "name": "street", "type": "string" },
            { "name": "city", "type": "string" }
          ]
        }
      },
      { "name": "courses", "type": { "type": "array", "items": "string" } }
    ]
  }
  ```