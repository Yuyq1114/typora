Linux 的 Shell 脚本是一种用于自动化操作的脚本语言，可以用来执行一系列的命令。Shell 是用户与操作系统之间的接口，它允许用户输入命令并执行。通过编写 Shell 脚本，可以将多个命令组合在一起，以完成复杂的任务。

## **基本概念**

1. **Shell 类型**：

   - **Bash (Bourne Again SHell)**：最常用的 Shell，提供了强大的功能。
   - **Sh (Bourne Shell)**：早期的 Shell，功能较少。
   - **Csh (C Shell)**：与 C 语言语法相似的 Shell。
   - **Zsh**：功能强大的 Shell，支持更多的特性。

2. **文件扩展名**：

   - Shell 脚本通常使用 `.sh` 作为文件扩展名，但实际上没有强制要求。

3. **执行权限**：

   - 在执行 Shell 脚本之前，需要确保脚本文件具有可执行权限，可以使用以下命令：

     ```
     chmod +x script.sh
     ```

### **脚本结构**

一个基本的 Shell 脚本结构如下：

```
#!/bin/bash
# 这是一个注释
echo "Hello, World!"  # 输出 "Hello, World!"
```

- `#!/bin/bash`：指定使用的 Shell 解释器，称为 shebang。
- 注释行以 `#` 开头。

### **基本命令**

1. **变量**：

   - 声明变量时，不需要空格：

     ```
     my_var="Hello"
     echo $my_var  # 输出 Hello
     ```

2. **`pwd` 命令**：
   `pwd`（print working directory）是一个Shell命令，它用于显示当前工作目录的完整路径。例如，如果当前工作目录是 `/home/user/project`，运行 `pwd` 将输出 `/home/user/project`。

   **反引号（```）**：
   反引号是Shell中的一种命令替换（Command Substitution）方式，它会执行其中的命令，并将命令的输出结果返回。也可以用 `$()` 代替反引号，例如：`root=$(pwd)，这两者效果相同。

   **变量赋值**：
   将 `pwd` 命令的输出结果（即当前工作目录的路径）赋值给 `root` 变量。

   ### 例子：

   ```
   #!/bin/bash
   root=`pwd`
   echo "当前目录是: $root"
   ```

3. **条件语句**：

   - 使用 

     ```
     if
     ```

      语句进行条件判断：

     ```
     if [ "$my_var" = "Hello" ]; then
         echo "Variable is Hello"
     else
         echo "Variable is not Hello"
     fi
     ```

4. **循环**：

   - 使用 `for` 循环：

     ```
     for i in {1..5}; do
         echo "Iteration $i"
     done
     ```

   - 使用 `while` 循环：

     ```
     count=1
     while [ $count -le 5 ]; do
         echo "Count is $count"
         ((count++))
     done
     ```

5. **函数**：

   - 定义和调用函数：

     ```
     my_function() {
         echo "This is my function"
     }
     
     my_function  # 调用函数
     ```

### **使用示例**

一个简单的 Shell 脚本示例，演示如何创建一个备份文件：

```
#!/bin/bash

# 备份目录
backup_dir="/path/to/backup"
# 要备份的文件
file_to_backup="/path/to/file"

# 创建备份
cp $file_to_backup $backup_dir

# 输出备份完成消息
echo "Backup of $file_to_backup completed in $backup_dir"
```

### **脚本调试**

在调试 Shell 脚本时，可以使用 `-x` 选项执行脚本，以便查看执行的每个命令：

```

bash -x script.sh
```

### **脚本执行**

要执行 Shell 脚本，可以使用以下两种方法之一：

1. 通过直接调用：

   ```
   
   ./script.sh
   ```

2. 通过 Shell 命令调用：

   ```
   
   bash script.sh
   ```

在Shell脚本中，`set -e` 是一种用于控制脚本执行行为的命令，具体作用是 **如果脚本中的任何命令返回非零退出状态（即命令失败），脚本将立即退出**，而不会继续执行后续的命令。



## $ 的使用

### 1. **引用变量**

- `$(变量名)` 用来引用变量的值。例如，如果定义了一个变量 `name`，可以通过 `$name` 获取其值。

#### 示例：

```
bash复制代码name="Alice"
echo $name  # 输出: Alice
```

在这个例子中，`$name` 就表示变量 `name` 的值。

### 2. **位置参数**

在脚本或函数中，`$` 后面加上数字（如 `$1`, `$2`, `$3` 等）用于引用传递给脚本或函数的参数。这些位置参数代表脚本被调用时传入的命令行参数。

#### 示例：

```
bash复制代码# 运行脚本时传递参数
./myscript.sh hello world

# 脚本内容
echo "第一参数是: $1"  # 输出: 第一参数是: hello
echo "第二参数是: $2"  # 输出: 第二参数是: world
```

- `$1`：第一个参数。
- `$2`：第二个参数。
- `$3`：第三个参数。
- 以此类推。

### 3. **特殊变量**

除了普通的变量引用外，Shell 中的 `$` 还和一些特殊变量一起使用，用来提供有关脚本或当前环境的其他信息。

#### 常见特殊变量：

- `$0`：脚本的名称。
- `$#`：传递给脚本或函数的参数个数。
- `$*`：所有参数的列表（作为一个单一的字符串）。
- `$@`：所有参数的列表（作为独立的字符串）。
- `$$`：当前 Shell 进程的 PID（进程 ID）。
- `$?`：上一个命令的退出状态码。
- `$!`：最后一个后台命令的进程 ID。
- `$-`：当前的 Shell 选项。

#### 示例：

```
bash复制代码# 运行脚本时传递参数
./myscript.sh arg1 arg2 arg3

echo "脚本名称: $0"   # 输出: 脚本名称: ./myscript.sh
echo "参数个数: $#"   # 输出: 参数个数: 3
echo "所有参数: $@"   # 输出: 所有参数: arg1 arg2 arg3
echo "最后命令退出状态: $?"   # 输出: 最后命令退出状态: 0（假设没有错误）
```

### 4. **命令替换（Command Substitution）**

`$()` 可以用于命令替换，它将命令的输出作为结果替换掉。这样，您可以将命令的输出直接用作变量的值或传递给其他命令。

#### 示例：

```
bash复制代码# 获取当前日期并存储在变量中
current_date=$(date)
echo "当前日期是: $current_date"
```

在这个例子中，`$(date)` 会被替换为 `date` 命令的输出，即当前日期和时间。

### 5. **表达式求值（Arithmetic Expansion）**

`$(( ))` 用于执行算术运算。在括号内，可以使用算术表达式，Shell 会计算结果并返回。

#### 示例：

```
bash复制代码a=5
b=3
sum=$((a + b))
echo "和是: $sum"   # 输出: 和是: 8
```

在这个例子中，`$((a + b))` 会计算 `a` 和 `b` 的和，并将结果赋给变量 `sum`。

### 6. **数组中的引用**

在 Bash 中，`$` 也可以用来引用数组中的元素。数组元素的索引从 0 开始，可以使用 `$array_name[index]` 来引用某个元素。

#### 示例：

```
bash复制代码array=("apple" "banana" "cherry")
echo ${array[0]}  # 输出: apple
echo ${array[1]}  # 输出: banana
```

在这个例子中，`${array[0]}` 引用了数组 `array` 中的第一个元素。

### 7. **动态变量名**

在某些情况下，你可能会想要使用动态的变量名，这时可以通过 `$` 和 `eval` 来实现。

#### 示例：

```
bash复制代码varname="dynamic_var"
eval $varname="Hello, World!"
echo $dynamic_var  # 输出: Hello, World!
```

在这个例子中，`eval` 使得 `$varname` 的值 `dynamic_var` 被动态地转换为变量名，并为其赋值。



## 判断

代码中的 []  执行基本的算数运算，如：result=$**[**a+b**]** *# 注意等号两边不能有空格*

[] 这个相当于test

[[]]是bash的扩展，支持模式匹配

**echo** "result 为： $result"

### 数值测试

| 参数 | 说明           |
| :--- | :------------- |
| -eq  | 等于则为真     |
| -ne  | 不等于则为真   |
| -gt  | 大于则为真     |
| -ge  | 大于等于则为真 |
| -lt  | 小于则为真     |
| -le  | 小于等于则为真 |

### 字符串测试

推荐使用引号包裹所有的字符串和变量，避免出现潜在的语法错误。

| 参数                         | 说明                     |
| :--------------------------- | :----------------------- |
| =     （==  可用于模式匹配） | 等于则为真               |
| !=                           | 不相等则为真             |
| -z 字符串                    | 字符串的长度为零则为真   |
| -n 字符串                    | 字符串的长度不为零则为真 |

### 文件测试

| 参数      | 说明                                 |
| :-------- | :----------------------------------- |
| -e 文件名 | 如果文件存在则为真                   |
| -r 文件名 | 如果文件存在且可读则为真             |
| -w 文件名 | 如果文件存在且可写则为真             |
| -x 文件名 | 如果文件存在且可执行则为真           |
| -s 文件名 | 如果文件存在且至少有一个字符则为真   |
| -d 文件名 | 如果文件存在且为目录则为真           |
| -f 文件名 | 如果文件存在且为普通文件则为真       |
| -c 文件名 | 如果文件存在且为字符型特殊文件则为真 |
| -b 文件名 | 如果文件存在且为块特殊文件则为真     |

## Shell 输入/输出重定向

大多数 UNIX 系统命令从你的终端接受输入并将所产生的输出发送回到您的终端。一个命令通常从一个叫标准输入的地方读取输入，默认情况下，这恰好是你的终端。同样，一个命令通常将其输出写入到标准输出，默认情况下，这也是你的终端。

重定向命令列表如下：

| 命令            | 说明                                               |
| :-------------- | :------------------------------------------------- |
| command > file  | 将输出重定向到 file。                              |
| command < file  | 将输入重定向到 file。                              |
| command >> file | 将输出以追加的方式重定向到 file。                  |
| n > file        | 将文件描述符为 n 的文件重定向到 file。             |
| n >> file       | 将文件描述符为 n 的文件以追加的方式重定向到 file。 |
| n >& m          | 将输出文件 m 和 n 合并。                           |
| n <& m          | 将输入文件 m 和 n 合并。                           |
| << tag          | 将开始标记 tag 和结束标记 tag 之间的内容作为输入。 |
